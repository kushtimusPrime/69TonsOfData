// Nathan Hellstedt, Kysh Hari, Charlie Little

import bc.Direction;
import bc.GameController;
import bc.GameMap;
import bc.Location;
import bc.MapLocation;
import bc.OrbitPattern;
import bc.Planet;
import bc.PlanetMap;
import bc.StartTurnMessage;
import bc.Team;
import bc.Unit;
import bc.UnitType;
import bc.VecUnit;
import bc.VecUnitID;
import bc.bc;
import java.util.ArrayList;
import java.util.Arrays;
import bc.Planet;


public class Player {
	
	private static int workerCount;
	private static int rocketCount;

     
	 public static void main(String[] args) throws NullPointerException {
	   GameController gc = new GameController();
	  gc.queueResearch(UnitType.Worker);
	     
	    for (int y=0;y<3;y++)
	  	{
	  		gc.queueResearch(UnitType.Rocket);
	  		
	  	
	  	}
	  	for (int x=0;x<3;x++)
	  	{
	  	    gc.queueResearch(UnitType.Knight);
        }
	  	for (int x=0;x<3;x++)
	  	{
	  		gc.queueResearch(UnitType.Healer);
	  	}
	  	for (int x=0;x<3;x++)
	  	{
	  		gc.queueResearch(UnitType.Ranger);
	  	}
	  	ArrayList<Unit> unbuiltFactories=new ArrayList<Unit>();
	  	ArrayList<Direction> directions=new ArrayList<Direction>();
	  	ArrayList<Unit> workers=new ArrayList<Unit>();
	  	ArrayList<Unit> builtFactories=new ArrayList<Unit>();
	  	ArrayList<Unit> knights=new ArrayList<Unit>();
	  	ArrayList<Unit> healers=new ArrayList<Unit>();
	  	ArrayList<Unit> mages=new ArrayList<Unit>();
	  	ArrayList<Unit> rangers=new ArrayList<Unit>();
	  	ArrayList<Unit> unbuiltRockets=new ArrayList<Unit>();
	  	ArrayList<Unit> builtRockets=new ArrayList<Unit>();
	  	ArrayList<MapLocation> karboniteLocationsEarth=new ArrayList<MapLocation>();
	  	
        directions=setDirectionsArrayList(gc,directions);
        Team myTeam;
        long buildHealer=0;
        int[] rotationTries= {0,-1,1,-2,2};
	  	PlanetMap planetMap=gc.startingMap(gc.planet());


	        
	        while (true) {
	        // Prints out current round and Karbonite number
	           System.out.println("Current round: "+gc.round());
	           System.out.println("Karbonite " + gc.karbonite());
	           
	           VecUnit current = gc.myUnits();
	           myTeam=gc.team();
	           for(int a=0;a<current.size();a++) {
	        	   	if(current.get(a).unitType().equals(UnitType.Factory)) {
	        	   		if(current.get(a).structureIsBuilt()==0) {
	        	   			unbuiltFactories.add(current.get(a));
	        	   		} else {
	        	   			builtFactories.add(current.get(a));
	        	   		}
	     
	        	   	}
	        	   	if(current.get(a).unitType().equals(UnitType.Rocket)) {
	        	   		if(current.get(a).structureIsBuilt()==0) {
	        	   			unbuiltRockets.add(current.get(a));
	        	   		} else {
	        	   			builtRockets.add(current.get(a));
	        	   		}
	     
	        	   	}
	        	   	if(current.get(a).unitType().equals(UnitType.Worker)) {
	        	   		workers.add(current.get(a));
	        	   	}
	        	   	if(current.get(a).unitType().equals(UnitType.Knight)) {
	        	   		knights.add(current.get(a));
	        	   	}
	        	   	if(current.get(a).unitType().equals(UnitType.Healer)) {
	        	   		healers.add(current.get(a));
	        	   	}
	        	   	if(current.get(a).unitType().equals(UnitType.Mage)) {
	        	   		mages.add(current.get(a));
	        	   	}
	        	   	if(current.get(a).unitType().equals(UnitType.Ranger)) {
	        	   		rangers.add(current.get(a));
	        	   	}

	           }
	           long factoryRound=gc.round()%50;
	           long karbonite=gc.karbonite();
	           if(factoryRound==1&&karbonite>=100) {
	        	   blueprintTheFactory(gc,directions,workers);
	           }
	           buildTheFactory(gc,unbuiltFactories,workers);
	           karbonite=gc.karbonite();
	           long roundNumber=gc.round()%2;
	           if(karbonite>20&&roundNumber==1) {
	        	   	buildKnights(gc,builtFactories);	        	   
	           }

	           unloadGarrison(gc,builtFactories,directions);
	   	  	if(gc.planet().equals(Planet.Earth)) {
	   		  	karboniteLocationsEarth=setKarboniteDestination(gc,karboniteLocationsEarth,planetMap);
	   		  	for(int workerTracker=0;workerTracker<workers.size();workerTracker++) {
	   		  		MapLocation placeToGo=finalKarboniteDestination(gc,workers.get(workerTracker),karboniteLocationsEarth);
	   		  	}
	   		}
	        	checkForKarbonite(gc, workers,directions);
	        	checkToReplicate(gc, workers);
	        	gc.nextTurn();
	           

	           
	        }
	        }
  
	
	        
	      // Checks for karbonite and mines karbonite if available
	      public static void checkForKarbonite(GameController gc, ArrayList<Unit> currentVec,ArrayList<Direction> directions) {
	    	  for (int i = 0; i < currentVec.size(); i++) {
	    		  Unit current = currentVec.get(i);
	    		  if(current.workerHasActed()==0) {
	    			  for(int a=0;a<directions.size();a++) {
	    				  if(gc.canHarvest(current.id(), directions.get(a))) {
	    					  gc.harvest(current.id(), directions.get(a));
	    				  }
	    			  }
	    		  }
	    	  }
	    		  
	    		/*  if (current.workerHasActed() == 0) {
	    			  
	    			  if (gc.canHarvest(current.id(), Direction.North))
	    				  gc.harvest(current.id(), Direction.North);
	    			  else if (gc.canHarvest(current.id(), Direction.Northeast))
	    				  gc.harvest(current.id(), Direction.Northeast);
	    			  else if (gc.canHarvest(current.id(), Direction.Northwest))
	    				  gc.harvest(current.id(), Direction.Northwest);
	    			  else if (gc.canHarvest(current.id(), Direction.East))
	    				  gc.harvest(current.id(), Direction.East);
	    			  else if (gc.canHarvest(current.id(), Direction.Southeast))
	    				  gc.harvest(current.id(), Direction.Southeast);
	    			  else if (gc.canHarvest(current.id(), Direction.Southwest))
	    				  gc.harvest(current.id(), Direction.Southwest);
	    			  else if (gc.canHarvest(current.id(), Direction.West))
	    				  gc.harvest(current.id(), Direction.West);
	    			  else if (gc.canHarvest(current.id(), Direction.South))
	    				  gc.harvest(current.id(), Direction.South);
	    			  else {

	    				  if (gc.canMove(current.id(), Direction.North) && current.movementHeat() < 10) {
	    					  System.out.println("Movement heat:"+current.movementHeat());
		    				  gc.moveRobot(current.id(), Direction.North);
	    				  }
		    			  else if (gc.canMove(current.id(), Direction.Northeast) && current.movementHeat() < 10)
		    				  gc.moveRobot(current.id(), Direction.Northeast);
		    			  else if (gc.canMove(current.id(), Direction.Northwest) && current.movementHeat() < 10)
		    				  gc.moveRobot(current.id(), Direction.Northwest);
		    			  else if (gc.canMove(current.id(), Direction.East) && current.movementHeat() < 10)
		    				  gc.moveRobot(current.id(), Direction.East);
		    			  else if (gc.canMove(current.id(), Direction.Southeast) && current.movementHeat() < 10)
		    				  gc.moveRobot(current.id(), Direction.Southeast);
		    			  else if (gc.canMove(current.id(), Direction.Southwest) && current.movementHeat() < 10)
		    				  gc.moveRobot(current.id(), Direction.Southwest);
		    			  else if (gc.canMove(current.id(), Direction.West) && current.movementHeat() < 10)
		    				  gc.moveRobot(current.id(), Direction.West);
		    			  else if (gc.canMove(current.id(), Direction.South) && current.movementHeat() < 10)
		    				  gc.moveRobot(current.id(), Direction.South);
	    				  }
	    			  }
	    		  }*/
	    	  }
	      
	     // Up to 50 workers, workers will replicate 
	      public static void checkToReplicate(GameController gc, ArrayList<Unit> current) {
	    	  if (workerCount <= 50) {
	    	  for (int i = 0; i < current.size(); i++) {
	    		  if (current.get(i).unitType() == UnitType.Worker) {
	    		  if (gc.canReplicate(current.get(i).id(), Direction.North) && gc.karbonite() >= 150 && current.get(i).abilityHeat() < 10) {
	    			  gc.replicate(current.get(i).id(), Direction.North);
	    			  workerCount++;
	    		  }
	    		  else if (gc.canReplicate(current.get(i).id(), Direction.Northeast) && gc.karbonite() >= 150 && current.get(i).abilityHeat() < 10) {
	    			  gc.replicate(current.get(i).id(), Direction.Northeast);
	    			  workerCount++;
	    		  }
	    		  else if (gc.canReplicate(current.get(i).id(), Direction.Northwest) && gc.karbonite() >= 150 && current.get(i).abilityHeat() < 10) {
	    			  gc.replicate(current.get(i).id(), Direction.Northwest);
	    			  workerCount++;
	    		  }
	    		else  if (gc.canReplicate(current.get(i).id(), Direction.East) && gc.karbonite() >= 150 && current.get(i).abilityHeat() < 10) {
		    			  gc.replicate(current.get(i).id(), Direction.East);
		    			  workerCount++;
		    		  
	    		  }
	    		else  if (gc.canReplicate(current.get(i).id(), Direction.West) && gc.karbonite() >= 150 && current.get(i).abilityHeat() < 10) {
	    			  gc.replicate(current.get(i).id(), Direction.West);
	    			  workerCount++;
  		  }
	    		else  if (gc.canReplicate(current.get(i).id(), Direction.South) && gc.karbonite() >= 150 && current.get(i).abilityHeat() < 10) {
	    			  gc.replicate(current.get(i).id(), Direction.South);
	    			  workerCount++;
  		  }
	    		else  if (gc.canReplicate(current.get(i).id(), Direction.Southeast) && gc.karbonite() >= 150 && current.get(i).abilityHeat() < 10) {
	    			  gc.replicate(current.get(i).id(), Direction.Southeast);
	    			  workerCount++;
  		  }
	    		else  if (gc.canReplicate(current.get(i).id(), Direction.Southwest) && gc.karbonite() >= 150 && current.get(i).abilityHeat() < 10) {
	    			  gc.replicate(current.get(i).id(), Direction.Southwest);
	    			  workerCount++;
	    		}	  
  		  }
	    	  }
	      }
	      }
	      

	      public static long getFirstLaunchRound(GameController gc) {
	    	  //currentPattern is the orbit pattern of the map
	    	  OrbitPattern currentPattern=gc.orbitPattern();
	    	  //marsArrivals is an arrayList that records when a rocket would arrive on Mars based on which round it launched
	    	  //marsArrivals keeps track of rounds 125-750 launches
	    	  ArrayList<Long> marsArrivals=new ArrayList<Long>();
	    	  //Puts the arrival round number into the ArrayList
	    	  for(int a=125;a<=750;a++) {
	    		  long duration=currentPattern.duration(a);
	    		  long arrival=duration+a;
	    		  	marsArrivals.add(arrival);
	    	  }
	    	  //min is the lowest Mars arrival time
	    	  long min=marsArrivals.get(0);
	    	  //leaveTime is a round number that determines when a rocket should leave Earth in order to get to Mars the quickest
	    	  int leaveTime=125;
	    	  //The loop determines the min value and the leaveTime value
	    	  for(int c=1;c<marsArrivals.size();c++) {
	    		  long potentialLaunch=marsArrivals.get(c);
	    		  if(potentialLaunch<min) {
	    			  min=potentialLaunch;
	    			  leaveTime=c+125;
	    		  }
	    	  }
	    	  return leaveTime;
	      }

          public static int blueprintTheFactory(GameController gc,ArrayList<Direction> directions,ArrayList<Unit> workers) {
        	  //System.out.println("Number of workers: "+workers.size());
        	  for(int a=0;a<workers.size();a++) {
        		  for(int b=0;b<directions.size();b++) {
        			  if(gc.canBlueprint(workers.get(a).id(), UnitType.Factory, directions.get(b))) {
        				  gc.blueprint(workers.get(a).id(), UnitType.Factory, directions.get(b));
        				  return 1;
        			  }
        		  }
        	  }
        	  
        	  return 0;
        	  
          }
     	 public static ArrayList<Direction> setDirectionsArrayList(GameController gc,ArrayList<Direction> directions) {
 	        directions.add(Direction.North);
 	        directions.add(Direction.Northeast);
 	        directions.add(Direction.East);
 	        directions.add(Direction.Southeast);
 	        directions.add(Direction.South);
 	        directions.add(Direction.Southwest);
 	        directions.add(Direction.West);
 	        directions.add(Direction.Northwest);
 	        return directions;
 	 }
     	 public static void buildTheFactory(GameController gc,ArrayList<Unit> unbuiltFactories,ArrayList<Unit> workers) {
     		 for(int a=0;a<workers.size();a++) {
     			 for(int b=0;b<unbuiltFactories.size();b++) {
     				 if(gc.canBuild(workers.get(a).id(), unbuiltFactories.get(b).id())) {
     					 gc.build(workers.get(a).id(), unbuiltFactories.get(b).id());
     				 }
     			 }
     		 } 
     	 }
     	 public static int buildKnights(GameController gc,ArrayList<Unit> builtFactories) {
     		 for(int a=0;a<builtFactories.size();a++) {
     			 if(gc.canProduceRobot(builtFactories.get(a).id(), UnitType.Knight) ) {
     				 gc.produceRobot(builtFactories.get(a).id(), UnitType.Knight);
     				 //System.out.println("produced a knight");
     				 return 1;
     			 }

     		 }
     		 return 0;
     		 
     	 }

     	 public static void unloadGarrison(GameController gc,ArrayList<Unit> builtFactories,ArrayList<Direction> directions) {
     		 for(int b=0;b<builtFactories.size();b++) {
     				 for(int d=0;d<directions.size();d++) {
     					 if(gc.canUnload(builtFactories.get(b).id(), directions.get(d))) {
     						 gc.unload(builtFactories.get(b).id(), directions.get(d));
     					 }
     				 }

     		 }
    
     		 
     	 }
     	 public static ArrayList<MapLocation> setKarboniteDestination(GameController gc,ArrayList<MapLocation> karboniteLocationsEarth,PlanetMap planetMap) {
     		 MapLocation mapLocation;
     		 for(int a=0;a<planetMap.getWidth();a++) {
     			 for(int b=0;b<planetMap.getHeight();b++) {
     				  mapLocation=new MapLocation(Planet.Earth,a,b);
     				 try {
     				 if(planetMap.initialKarboniteAt(mapLocation)>0) {
     					 karboniteLocationsEarth.add(mapLocation);
     				 }
     				 } catch (Exception e) {
     					 
     				 }
     			 }
     		 }
     		 return karboniteLocationsEarth;
     	 }
     	 public static MapLocation finalKarboniteDestination(GameController gc, Unit worker,ArrayList<MapLocation> karboniteLocationsEarth) {
     		 int min=1000;
     		 MapLocation optimalMapLocation=null;
     		 for(int a=0;a<karboniteLocationsEarth.size();a++) {
     			 MapLocation workerLocation=worker.location().mapLocation();
     			 int xDiff=(workerLocation.getX()-karboniteLocationsEarth.get(a).getX())*(workerLocation.getX()-karboniteLocationsEarth.get(a).getX());
     			 int yDiff=(workerLocation.getY()-karboniteLocationsEarth.get(a).getY())*(workerLocation.getY()-karboniteLocationsEarth.get(a).getY());
     			 System.out.println("xDiff: "+xDiff+"yDiff: "+yDiff);
     		 }
     		 return optimalMapLocation;
     	 }
     	 /*
     	  * main method implementation
     	  * for(allWorkers) {
     	  * 		finalKarboniteDestination(gc,worker);
     	  * }
     	  */
 	  	/* This picks the specific destination for each worker to move to for karbonite
 	  	 *MapLocation moveToKarbonite() {
 	  	 *int min=1000;
 	  	 *MapLocation optimalMapLocation=null;
 	  	 *for(workers)
 	  	 *	for(karbonite)
 	  	 *		maplocation=workerlocation=workers.maplocation
 	  	 *		xDiff=(maplocation.getX-karbonite.getX)*(maplocation.getX-karbonite.getX);
 	  	 *		yDiff=(maplocation.getY-karbonite.getY)*(maplocation.getY-karbonite.getY);
 	  	 *		distance=xDiff+yDiff;
 	  	 *		if(distance<min) {
 	  	 *			min=distance;
 	  	 *			optimalMapLocation=karbonite;
 	  	 *		}
 	  	 *return optimalMapLocation;
 	  	 *}
 	  	 */
}
